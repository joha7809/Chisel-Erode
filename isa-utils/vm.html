<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Bytecode VM Project Summary</title>
    <style>
      body {
        font-family: sans-serif;
        line-height: 1.5;
        margin: 2rem;
      }
      h1,
      h2,
      h3,
      h4 {
        color: #2c3e50;
      }
      pre {
        background: #f4f4f4;
        padding: 1rem;
        overflow-x: auto;
      }
      code {
        font-family: monospace;
      }
    </style>
  </head>
  <body>
    <h1>Bytecode VM Project Summary</h1>

    <h2>1️⃣ Core Goals</h2>
    <ul>
      <li>
        Build a simple <strong>RISC-style VM</strong> for your custom ISA.
      </li>
      <li>Execute instructions, manage registers and memory.</li>
      <li>
        Experiment with
        <strong>Rust traits, generics, and executor composition</strong>.
      </li>
      <li>Optional: logging, profiling, infinite loop detection, and stack.</li>
    </ul>

    <h2>2️⃣ Project Structure</h2>
    <pre>
bytecode_vm/
├── Cargo.toml
├── src/
│   ├── main.rs
│   ├── vm/
│   │   ├── mod.rs
│   │   ├── vm.rs
│   │   ├── memory.rs
│   │   ├── executor.rs
│   │   ├── interpreter.rs
│   │   ├── logging.rs
│   │   ├── profiler.rs
│   ├── instruction.rs
│   ├── assembler.rs
│   ├── utils.rs
│   └── tests/
│       ├── vm_tests.rs
│       ├── executor_tests.rs
</pre
    >

    <h2>3️⃣ Key Rust Features to Use</h2>
    <ul>
      <li>Traits: Memory, Executor, optional Stack</li>
      <li>
        Generics: VM generic over executor (&lt;E: Executor&gt;),
        FixedMemory&lt;const N: usize&gt;, FixedMemoryStack&lt;const N:
        usize&gt;
      </li>
      <li>Enums: Instruction, VMError</li>
      <li>
        Composition: Wrapper executors (LoggingExecutor, LoopProfilerExecutor)
      </li>
      <li>Dynamic dispatch (optional): Box&lt;dyn Memory&gt;</li>
    </ul>

    <h2>4️⃣ VM State (<code>vm.rs</code>)</h2>
    <pre><code class="language-rust">
pub struct VM<E: Executor> {
    pub registers: [i32; 32],
    pub memory: Box&lt;dyn Memory&gt;,
    pub pc: usize,
    pub program: Vec&lt;Instruction&gt;,
    pub running: bool,
    pub executor: E,
}

impl&lt;E: Executor&gt; VM&lt;E&gt; {
    pub fn run(&mut self) -&gt; Result&lt;(), VMError&gt; {
        self.running = true;
        while self.running &amp;&amp; self.pc &lt; self.program.len() {
            let instr = &self.program[self.pc];
            self.executor.execute(instr, self)?;
        }
        Ok(())
    }
}
</code></pre>

    <!-- Repeat sections similarly for Memory, Instructions, Executor, Stack, Errors, etc. -->
  </body>
</html>
